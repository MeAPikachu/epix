Open PicoBlaze Assembler log for program "EpixStartupCode.psm"
Generated by opbasm v1.2.2
  Assembled on 2015-04-07T13:45:35
  PicoBlaze-6 mode

  Last occupied address: 198 hex
  Nominal program memory size: 1K (1024)  address(9:0)
  Actual memory size: 4096
  Occupied memory locations: 409
  Memory locations available: 3687
  Scratchpad size: 64


Assembly listing
----------------
000                             ;Input Ports (ip)
000                             CONSTANT ipVcRegInStatus, 00   ; Bit 0 - reg ack, Bit 1 - reg fail
000                             CONSTANT ipVcRegInData, 01     ; Data byte
000                             CONSTANT ipAdcValidCount, 02   ; Byte of counter data.  # of valids over last 256 cycles
000                             CONSTANT ipAdcMatchCount, 03   ; Byte of counter data.  # of matched ADC words over last 256 cycles
000                             CONSTANT ipHandshaking, 04     ; Bit 0 - startup request
000                             ;Output ports (op)
000                             CONSTANT opRegWrAddr, 01       ; Byte of register address
000                             CONSTANT opRegWrData, 02       ; Byte of register data
000                             CONSTANT opAdcReg, 04          ; Bit 7 - enable ADC reg access, Bit 4:0 - adc/ch select
000                             CONSTANT opAsicReg, 08         ; Bit 7 - enable ASIC reg access, Bit 1:0 - asic select
000                             CONSTANT opRegRequest, 10      ; Bit 1 - reg request, Bit 0 - read/write bit (1 is write)
000                             CONSTANT opHandshaking, 20     ; Bit 1 - startup failed, Bit 0 - startup acknowledged
000                             ;Register addresses (r) (from RegControl.vhd)
000                             CONSTANT rPower, 08            ; Power Enable is register 0x000008
000                             CONSTANT rClock, 26            ; AdcClkHalfT is register  0x000026
000                             CONSTANT rSaciClkBit, 28       ; Saci clock bit is register 0x000028
000                             CONSTANT rAdcPdwn, 1E          ; AdcPowerDown is register 0x00001E
000                             CONSTANT rAdcRegTestPatt, 0D   ; Adc space test pattern register
000                             CONSTANT rAdcRegExecute, FF    ; Adc space transfer register
000                             CONSTANT rAsicMask, 0D         ; Asic mask register
000                             CONSTANT rBaseFrameDelay, 60   ; First frame delay register
000                             CONSTANT rBaseDataDelay, 63    ; First data delay register
000                             ;Other useful constants (c)
000                             CONSTANT cPowerUp, 03          ; Digital and analog power up, FPGA outputs disabled
000                             CONSTANT cPowerUpAll, 07       ; Digital and analog power up, FPGA outputs enabled
000                             CONSTANT cClk50MHz, 01         ; Clock half period is 1 cycle (50 MSPS)
000                             CONSTANT cSaciClkBit, 04       ; Clock rate is 100 MHz / 2^(cSaciClkBit+1)
000                             CONSTANT cRegWrite, 03         ; Reg req - 1, Read/write - 1
000                             CONSTANT cAdcPdwn, 07          ; Power down all 3 ADCs
000                             CONSTANT cAdcPup, 00           ; Power up all ADCs
000                             CONSTANT cAdcRegEn, 80         ; Enable bit for ADC register access
000                             CONSTANT cAdcMixedBitPatt, 0C  ; Mixed bit pattern select for ADCs
000                             CONSTANT cAdcNoTestPatt, 00    ; Test pattern disable
000                             CONSTANT cAdcTransferBit, 01   ; Transfer bit for ADCs
000                             CONSTANT cLastAdc, 02          ; 3 ADCs on this board, 0,1,2
000                             CONSTANT cLastAsic, 03         ; 4 ASICs on this board,0,1,2,3
000                             CONSTANT cLastFrame, 02        ; 3 frame signals to be aligned
000                             CONSTANT cLastData, 13         ; 20 data signals to be aligned
000                             CONSTANT cStartFrameDelay, 13  ; Starting point for frame delay (19 ~ 1 bit period away from 0)
000                             CONSTANT cLastDataDelay, 25    ; End scanning ~1 bit period after highest frame delay
000                             CONSTANT cAllGood, 7F          ; counter value for all good data
000                             ;Reserved/named registers (s)
000                             NAMEREG s0, sInArg0
000                             NAMEREG s1, sInArg1
000                             NAMEREG s2, sInArg2
000                             NAMEREG s3, sInArg3
000                             NAMEREG s4, sOutArg0
000                             NAMEREG s5, sOutArg1
000                             NAMEREG s6, sOutArg2
000                             NAMEREG s7, sOutArg3
000                             NAMEREG s8, sAsicMask
000                             NAMEREG s9, sAsicMaskFinal
000                             NAMEREG sa, sStartupFail
000                             NAMEREG sb, sScratch0
000                             NAMEREG sc, sScratch1
000                             NAMEREG sd, sScratch2
000                             NAMEREG se, sScratch3
000                             ;Reserved scratchpad spaces (scratchpad ends at 3F)
000                             CONSTANT mCurAdc, 00
000                             CONSTANT mCurCh, 01
000                             CONSTANT mCurDelay, 02
000                             CONSTANT mFirstGood, 03
000                             CONSTANT mFrameDelay0, 05
000                             CONSTANT mFrameDelay1, 06
000                             CONSTANT mFrameDelay2, 07
000                             CONSTANT mBaseChDelay, 08
000                             CONSTANT mFailFlag0, 10
000                             CONSTANT mFailFlag1, 11
000                             CONSTANT mFailFlag2, 12
000                             CONSTANT mInput0, 30
000                             CONSTANT mInput1, 31
000                             CONSTANT mInput2, 32
000                             CONSTANT mInput3, 33


000                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000                             ;;Main - poll request port until you see a 1, then go
000                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000                      fMain:
000  09004                      INPUT sInArg0, ipHandshaking   ;Read the input port
001  0D001                      TEST sInArg0, 01               ;Test the LSB, if set, carry = 1, if not, zero = 1
002  3E000                      JUMP NC, fMain                 ;If carry isn't set, return to start and poll again
003                             ;Otherwise, initiate startup sequence
003  20017                      CALL fPowerUp                  ; 1) Start up the power
004  2001D                      CALL fClockUp                  ; 2) Start up ADC clock at 50 MHz
005  20022                      CALL fFpgaOutUp                ; 3) Bring FPGA outputs out of tristate
006  20026                      CALL fCycleAdcs                ; 4) Power cycle ADCs
007  2003F                      CALL fSetDefaultFrame          ; 5) Set default frame alignment
008  20034                      CALL fTestEn                   ; 6) Start test patterns on all ADCs
009                fAlignAgain:
009  200CE                      CALL fDataAlign                ; 8) Data alignment sequence
00A  20058                      CALL fDataSuccessCheck         ; 9) Check for failures
00B  1D400                      COMPARE sOutArg0, 00           ;
00C  32012                      JUMP Z, fAlignFinish           ;    - No failures, jump to finish
00D  20061                      CALL fFrameAlign               ;10) - Failures, adjust alignment
00E  1D400                      COMPARE sOutArg0, 00           ;    Did frame alignment fail?
00F  36011                      JUMP NZ, fAlignFail            ;    - Yes, jump to finish having failed
010  22009                      JUMP fAlignAgain               ;    - No, run through the data alignment with new frame alignments
011                 fAlignFail:
011  04A40                      OR sStartupFail, sOutArg0
012               fAlignFinish:
012  20080                      CALL fFrameFineAlign           ;10.5) Center frame to avoid being stuck on edge
013  2011C                      CALL fTestDis                  ;11) ADC test pattern off
014  20127                      CALL fFindAsics                ;12) Determine which ASICs are connected
015  2013B                      CALL fAck                      ;13) Complete acknowledgement (hold here until startup req drops low)
016  22000                      JUMP fMain                     ;14) Return to beginning of loop

017                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
017                             ;;Power up analog and digital power
017                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
017                   fPowerUp:
017  01A00                      LOAD sStartupFail, 00
018  01008                      LOAD sInArg0, rPower
019  01103                      LOAD sInArg1, cPowerUp
01A  20145                      CALL fWriteReg
01B  2017D                      CALL fWait300ms                ; Long wait to let power settle
01C  25000                      RETURN

01D                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
01D                             ;;Setup ADC clock
01D                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
01D                   fClockUp:
01D  01026                      LOAD sInArg0, rClock
01E  01101                      LOAD sInArg1, cClk50MHz
01F  20145                      CALL fWriteReg
020  2017D                      CALL fWait300ms                ; Long wait to let power settle
021  25000                      RETURN

022                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
022                             ;;Enable the FPGA outputs
022                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
022                 fFpgaOutUp:
022  01008                      LOAD sInArg0, rPower
023  01107                      LOAD sInArg1, cPowerUpAll
024  20145                      CALL fWriteReg
025  25000                      RETURN

026                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
026                             ;;Power cycle ADCs
026                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
026                 fCycleAdcs:
026  0101E                      LOAD sInArg0, rAdcPdwn
027  01107                      LOAD sInArg1, cAdcPdwn
028  20145                      CALL fWriteReg
029  012FF                      LOAD sInArg2, FF
02A  01114                      LOAD sInArg1, 14
02B  20185                      CALL fLongWait
02C  0101E                      LOAD sInArg0, rAdcPdwn
02D  01100                      LOAD sInArg1, cAdcPup
02E  20145                      CALL fWriteReg
02F  012FF                      LOAD sInArg2, FF               ; Wait for ~20*20 us
030  01114                      LOAD sInArg1, 14
031  20185                      CALL fLongWait
032  2017D                      CALL fWait300ms                ; Long wait to let power settle
033  25000                      RETURN

034                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
034                             ;;Load up ADC test patterns
034                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
034                    fTestEn:
034  01200                      LOAD sInArg2, 00
035                    fNextEn:
035  0100D                      LOAD sInArg0, rAdcRegTestPatt
036  0110C                      LOAD sInArg1, cAdcMixedBitPatt
037  2014F                      CALL fWrAdcReg
038  010FF                      LOAD sInArg0, rAdcRegExecute
039  01101                      LOAD sInArg1, cAdcTransferBit
03A  2014F                      CALL fWrAdcReg
03B  1D202                      COMPARE sInArg2, cLastAdc
03C  31000                      RETURN Z
03D  11201                      ADD sInArg2, 01
03E  22035                      JUMP fNextEn

03F                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
03F                             ;;Set default frame alignment on all ADCs
03F                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
03F           fSetDefaultFrame:
03F  01B13                      LOAD sScratch0, cStartFrameDelay
040  2FB05                      STORE sScratch0, mFrameDelay0
041  2FB06                      STORE sScratch0, mFrameDelay1
042  2FB07                      STORE sScratch0, mFrameDelay2
043  01B00                      LOAD sScratch0, 00
044  2FB00                      STORE sScratch0, mCurAdc
045  2FB01                      STORE sScratch0, mCurCh
046  01B13                      LOAD sScratch0, cStartFrameDelay
047  2FB02                      STORE sScratch0, mCurDelay
048          fNextDefaultFrame:
048  01060                      LOAD sInArg0, rBaseFrameDelay  ; Select current ADC register
049  0BB00                      FETCH sScratch0, mCurAdc
04A  100B0                      ADD sInArg0, sScratch0
04B  0B102                      FETCH sInArg1, mCurDelay
04C  20145                      CALL fWriteReg
04D  0BB00                      FETCH sScratch0, mCurAdc
04E  1DB02                      COMPARE sScratch0, cLastFrame
04F  31000                      RETURN Z
050  11B01                      ADD sScratch0, 01
051  2FB00                      STORE sScratch0, mCurAdc
052  0BB01                      FETCH sScratch0, mCurCh
053  11B08                      ADD sScratch0, 08
054  2FB01                      STORE sScratch0, mCurCh
055  01B13                      LOAD sScratch0, cStartFrameDelay
056  2FB02                      STORE sScratch0, mCurDelay
057  22048                      JUMP fNextDefaultFrame

058                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
058                             ;;Check the failure flags
058                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
058          fDataSuccessCheck:
058  01B00                      LOAD sScratch0, 00
059  0BC10                      FETCH sScratch1, mFailFlag0
05A  10BC0                      ADD sScratch0, sScratch1
05B  0BC11                      FETCH sScratch1, mFailFlag1
05C  10BC0                      ADD sScratch0, sScratch1
05D  0BC12                      FETCH sScratch1, mFailFlag2
05E  10BC0                      ADD sScratch0, sScratch1
05F  004B0                      LOAD sOutArg0, sScratch0
060  25000                      RETURN

061                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
061                             ;;Perform frame alignment based on fail flags
061                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
061                fFrameAlign:
061  01B00                      LOAD sScratch0, 00             ; Initialize ADC counter
062  2FB00                      STORE sScratch0, mCurAdc
063                 fNextFrame:
063  0BC10                      FETCH sScratch1, mFailFlag0    ; Calculate address of current ADC fail flag in scratchpad
064  0BB00                      FETCH sScratch0, mCurAdc
065  10CB0                      ADD sScratch1, sScratch0
066  0ABC0                      FETCH sScratch0, (sScratch1)
067  1DB00                      COMPARE sScratch0, 00          ; Z will be set if there was no failure
068  32076                      JUMP Z, fFrameChIncr
069                             ; Otherwise, increment the delay
069  01C05                      LOAD sScratch1, mFrameDelay0   ; Calculate address of current ADC delay in scratchpad
06A  0BB00                      FETCH sScratch0, mCurAdc
06B  10CB0                      ADD sScratch1, sScratch0
06C  0ABC0                      FETCH sScratch0, (sScratch1)   ; Place current delay in sScratch0
06D  1DB00                      COMPARE sScratch0, 00          ; Is this the last delay?
06E  3207C                      JUMP Z, fFrameFail             ; If so, return failure so we can stop trying
06F  19B01                      SUB sScratch0, 01              ; Otherwise, decrement the delay by 1
070  2EBC0                      STORE sScratch0, (sScratch1)   ; Store it in the same location in scratchpad
071                             ; Write the delay out with a function call
071  01060                      LOAD sInArg0, rBaseFrameDelay  ; Select current ADC register
072  0BB00                      FETCH sScratch0, mCurAdc
073  100B0                      ADD sInArg0, sScratch0
074  0A1C0                      FETCH sInArg1, (sScratch1)     ; Set the current delay
075  20145                      CALL fWriteReg
076               fFrameChIncr:
076  0BB00                      FETCH sScratch0, mCurAdc       ; Move on to the next channel
077  1DB02                      COMPARE sScratch0, cLastFrame
078  3207E                      JUMP Z, fFrameSucc             ; Successful completion
079  11B01                      ADD sScratch0, 01
07A  2FB00                      STORE sScratch0, mCurAdc
07B  22063                      JUMP fNextFrame

07C                 fFrameFail:
07C  01401                      LOAD sOutArg0, 01
07D  25000                      RETURN
07E                 fFrameSucc:
07E  01400                      LOAD sOutArg0, 00
07F  25000                      RETURN

080                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
080                             ;;Realign frames to center them
080                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
080            fFrameFineAlign:
080  01B00                      LOAD sScratch0, 00
081  2FB00                      STORE sScratch0, mCurAdc
082  2FB02                      STORE sScratch0, mCurDelay
083  2FB03                      STORE sScratch0, mFirstGood
084  2FB10                      STORE sScratch0, mFailFlag0
085  2FB11                      STORE sScratch0, mFailFlag1
086  2FB12                      STORE sScratch0, mFailFlag2
087             fFrameFineNext:
087  01060                      LOAD sInArg0, rBaseFrameDelay  ; Select current ADC register
088  0BB00                      FETCH sScratch0, mCurAdc
089  100B0                      ADD sInArg0, sScratch0
08A  0B102                      FETCH sInArg1, mCurDelay
08B  20145                      CALL fWriteReg
08C  0BB00                      FETCH sScratch0, mCurAdc       ; Monitor the counter for the current channel
08D  14B06                      SL0 sScratch0                  ; Use ch0 for that ADC (shift left by 3 ==> x8)
08E  14B06                      SL0 sScratch0
08F  14B06                      SL0 sScratch0
090  2DB04                      OUTPUT sScratch0, opAdcReg
091  01C00                      LOAD sScratch1, 00             ; 16-bit counter in scratch1-2
092  01D00                      LOAD sScratch2, 00
093  01EFF                      LOAD sScratch3, FF             ; Count down to do 256 reads (SIMULATION NOTE: reduce to speed up)
094          fFrameFineMeasure:
094  01044                      LOAD sInArg0, 44               ; Wait ~5.4 us (256 samples @ 50 MHz would be 5.12 us)
095  2018B                      CALL fWait
096  09B03                      INPUT sScratch0, ipAdcMatchCount
097  10CB0                      ADD sScratch1, sScratch0
098  13D00                      ADDCY sScratch2, 00
099  19E01                      SUB sScratch3, 01
09A  1DE00                      COMPARE sScratch3, 00
09B  36094                      JUMP NZ, fFrameFineMeasure
09C  04DC0                      OR sScratch2, sScratch1
09D  1DD00                      COMPARE sScratch2, 00          ; Zero will be set if no errors were detected
09E  320A6                      JUMP Z, fFrameFineFirstGood
09F  220AC                      JUMP fFrameFineLastGood
0A0        fFrameFineNextDelay:
0A0  0BB02                      FETCH sScratch0, mCurDelay
0A1  1DB25                      COMPARE sScratch0, cLastDataDelay ; Last allowed delay
0A2  320BA                      JUMP Z, fFrameFineSetFail      ; If we've gotten here, calibration failed
0A3  11B01                      ADD sScratch0, 01
0A4  2FB02                      STORE sScratch0, mCurDelay
0A5  22087                      JUMP fFrameFineNext
0A6        fFrameFineFirstGood:
0A6  0BB03                      FETCH sScratch0, mFirstGood
0A7  1DB00                      COMPARE sScratch0, 00
0A8  360A0                      JUMP NZ, fFrameFineNextDelay   ; If we've already found the first good one, move along
0A9  0BB02                      FETCH sScratch0, mCurDelay     ; Otherwise, store this one
0AA  2FB03                      STORE sScratch0, mFirstGood
0AB  220A0                      JUMP fFrameFineNextDelay
0AC         fFrameFineLastGood:
0AC  0BB03                      FETCH sScratch0, mFirstGood
0AD  1DB00                      COMPARE sScratch0, 00
0AE  320A0                      JUMP Z, fFrameFineNextDelay    ; If we haven't yet found the first good one, move along
0AF  0BB02                      FETCH sScratch0, mCurDelay     ; Otherwise, this is the first bad one after good.
0B0  19B01                      SUB sScratch0, 01              ; The one before it was the last good
0B1  0BC03                      FETCH sScratch1, mFirstGood    ; Average that one and the first good one
0B2  10CB0                      ADD sScratch1, sScratch0
0B3  14C0E                      SR0 sScratch1
0B4  01060                      LOAD sInArg0, rBaseFrameDelay  ; Load it up into the current register
0B5  0BB00                      FETCH sScratch0, mCurAdc
0B6  100B0                      ADD sInArg0, sScratch0
0B7  001C0                      LOAD sInArg1, sScratch1
0B8  20145                      CALL fWriteReg                 ; Since we found the last good sample, complete here
0B9  220C5                      JUMP fFrameFineIncrData        ; Make sure to skip writing the fail flag
0BA          fFrameFineSetFail:
0BA  0BB00                      FETCH sScratch0, mCurAdc       ; Convert current channel to ADC value by shifting 3 bits right
0BB  00DB0                      LOAD sScratch2, sScratch0      ; Store the current ADC for use in a moment
0BC  01C10                      LOAD sScratch1, mFailFlag0
0BD  10CB0                      ADD sScratch1, sScratch0
0BE  01B01                      LOAD sScratch0, 01
0BF  2EBC0                      STORE sScratch0, (sScratch1)
0C0  1DD02                      COMPARE sScratch2, cLastAdc    ; Was this last ADC?  If so, return
0C1  31000                      RETURN Z
0C2  0BB01                      FETCH sScratch0, mCurCh        ; Otherwise, skip over remaining channels on this ADC
0C3  05B07                      OR sScratch0, 07               ; Do this by setting the lowest 3 bits to 111, and let
0C4  2FB01                      STORE sScratch0, mCurCh        ; the next block increment
0C5         fFrameFineIncrData:
0C5  0BB00                      FETCH sScratch0, mCurAdc       ; Are we done?  Check for last adc
0C6  1DB02                      COMPARE sScratch0, cLastAdc
0C7  31000                      RETURN Z                       ; Compare matched, we're done
0C8  11B01                      ADD sScratch0, 01              ; Otherwise, increment channel and store it to scratchpad
0C9  2FB00                      STORE sScratch0, mCurAdc
0CA  01B00                      LOAD sScratch0, 00             ; Reset delay and good flags before moving on to next channel
0CB  2FB02                      STORE sScratch0, mCurDelay
0CC  2FB03                      STORE sScratch0, mFirstGood
0CD  22087                      JUMP fFrameFineNext

0CE                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0CE                             ;;Perform data alignment on all ADCs
0CE                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0CE                 fDataAlign:
0CE  01B00                      LOAD sScratch0, 00
0CF  2FB01                      STORE sScratch0, mCurCh
0D0  2FB02                      STORE sScratch0, mCurDelay
0D1  2FB03                      STORE sScratch0, mFirstGood
0D2  2FB10                      STORE sScratch0, mFailFlag0
0D3  2FB11                      STORE sScratch0, mFailFlag1
0D4  2FB12                      STORE sScratch0, mFailFlag2
0D5                  fNextData:
0D5  01063                      LOAD sInArg0, rBaseDataDelay   ; Select current ADC register
0D6  0BB01                      FETCH sScratch0, mCurCh
0D7  100B0                      ADD sInArg0, sScratch0
0D8  0B102                      FETCH sInArg1, mCurDelay
0D9  20145                      CALL fWriteReg
0DA  0BB01                      FETCH sScratch0, mCurCh        ; Monitor the counter for the current channel
0DB  2DB04                      OUTPUT sScratch0, opAdcReg
0DC  01C00                      LOAD sScratch1, 00             ; 16-bit counter in scratch1-2
0DD  01D00                      LOAD sScratch2, 00
0DE  01EFF                      LOAD sScratch3, FF             ; Count down to do 256 reads (SIMULATION NOTE: reduce to speed up)
0DF               fDataMeasure:
0DF  01044                      LOAD sInArg0, 44               ; Wait ~5.4 us (256 samples @ 50 MHz would be 5.12 us)
0E0  2018B                      CALL fWait
0E1  09B03                      INPUT sScratch0, ipAdcMatchCount
0E2  10CB0                      ADD sScratch1, sScratch0
0E3  13D00                      ADDCY sScratch2, 00
0E4  19E01                      SUB sScratch3, 01
0E5  1DE00                      COMPARE sScratch3, 00
0E6  360DF                      JUMP NZ, fDataMeasure
0E7  04DC0                      OR sScratch2, sScratch1
0E8  1DD00                      COMPARE sScratch2, 00          ; Zero will be set if no errors were detected
0E9  320F1                      JUMP Z, fFirstGood
0EA  220F7                      JUMP fLastGood
0EB                 fNextDelay:
0EB  0BB02                      FETCH sScratch0, mCurDelay
0EC  1DB25                      COMPARE sScratch0, cLastDataDelay ; Last allowed delay
0ED  32105                      JUMP Z, fSetFail               ; If we've gotten here, calibration failed
0EE  11B01                      ADD sScratch0, 01
0EF  2FB02                      STORE sScratch0, mCurDelay
0F0  220D5                      JUMP fNextData

0F1                 fFirstGood:
0F1  0BB03                      FETCH sScratch0, mFirstGood
0F2  1DB00                      COMPARE sScratch0, 00
0F3  360EB                      JUMP NZ, fNextDelay            ; If we've already found the first good one, move along
0F4  0BB02                      FETCH sScratch0, mCurDelay     ; Otherwise, store this one
0F5  2FB03                      STORE sScratch0, mFirstGood
0F6  220EB                      JUMP fNextDelay
0F7                  fLastGood:
0F7  0BB03                      FETCH sScratch0, mFirstGood
0F8  1DB00                      COMPARE sScratch0, 00
0F9  320EB                      JUMP Z, fNextDelay             ; If we haven't yet found the first good one, move along
0FA  0BB02                      FETCH sScratch0, mCurDelay     ; Otherwise, this is the first bad one after good.
0FB  19B01                      SUB sScratch0, 01              ; The one before it was the last good
0FC  0BC03                      FETCH sScratch1, mFirstGood    ; Average that one and the first good one
0FD  10CB0                      ADD sScratch1, sScratch0
0FE  14C0E                      SR0 sScratch1
0FF  01063                      LOAD sInArg0, rBaseDataDelay   ; Load it up into the current register
100  0BB01                      FETCH sScratch0, mCurCh
101  100B0                      ADD sInArg0, sScratch0
102  001C0                      LOAD sInArg1, sScratch1
103  20145                      CALL fWriteReg                 ; Since we found the last good sample, complete here
104  22113                      JUMP fIncrData                 ; Make sure to skip writing the fail flag
105                   fSetFail:
105  0BB01                      FETCH sScratch0, mCurCh        ; Convert current channel to ADC value by shifting 3 bits right
106  14B0E                      SR0 sScratch0
107  14B0E                      SR0 sScratch0
108  14B0E                      SR0 sScratch0
109  00DB0                      LOAD sScratch2, sScratch0      ; Store the current ADC for use in a moment
10A  01C10                      LOAD sScratch1, mFailFlag0
10B  10CB0                      ADD sScratch1, sScratch0
10C  01B01                      LOAD sScratch0, 01
10D  2EBC0                      STORE sScratch0, (sScratch1)
10E  1DD02                      COMPARE sScratch2, cLastAdc    ; Was this last ADC?  If so, return
10F  31000                      RETURN Z
110  0BB01                      FETCH sScratch0, mCurCh        ; Otherwise, skip over remaining channels on this ADC
111  05B07                      OR sScratch0, 07               ; Do this by setting the lowest 3 bits to 111, and let
112  2FB01                      STORE sScratch0, mCurCh        ; the next block increment
113                  fIncrData:
113  0BB01                      FETCH sScratch0, mCurCh        ; Are we done?  Check for last channel
114  1DB13                      COMPARE sScratch0, cLastData
115  31000                      RETURN Z                       ; Compare matched, we're done
116  11B01                      ADD sScratch0, 01              ; Otherwise, increment channel and store it to scratchpad
117  2FB01                      STORE sScratch0, mCurCh
118  01B00                      LOAD sScratch0, 00             ; Reset delay and good flags before moving on to next channel
119  2FB02                      STORE sScratch0, mCurDelay
11A  2FB03                      STORE sScratch0, mFirstGood
11B  220D5                      JUMP fNextData

11C                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
11C                             ;;Disable test mode on all ADCs
11C                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
11C                   fTestDis:
11C  01200                      LOAD sInArg2, 00
11D                   fNextDis:
11D  0100D                      LOAD sInArg0, rAdcRegTestPatt
11E  01100                      LOAD sInArg1, cAdcNoTestPatt
11F  2014F                      CALL fWrAdcReg
120  010FF                      LOAD sInArg0, rAdcRegExecute
121  01101                      LOAD sInArg1, cAdcTransferBit
122  2014F                      CALL fWrAdcReg
123  1D202                      COMPARE sInArg2, cLastAdc
124  31000                      RETURN Z
125  11201                      ADD sInArg2, 01
126  2211D                      JUMP fNextDis

127                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
127                             ;;Send a command to identify connected ASICs
127                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
127                 fFindAsics:
127  01028                      LOAD sInArg0, rSaciClkBit      ; First turn on the SACI clock
128  01104                      LOAD sInArg1, cSaciClkBit
129  20145                      CALL fWriteReg
12A  01200                      LOAD sInArg2, 00               ; Set up to send a command to each ASIC
12B  01801                      LOAD sAsicMask, 01
12C  01900                      LOAD sAsicMaskFinal, 00
12D                  fNextAsic:
12D  2015E                      CALL fWrAsicReg
12E  1D400                      COMPARE sOutArg0, 00
12F  30135                      CALL Z, fSetAsicBit
130  1D203                      COMPARE sInArg2, cLastAsic
131  32137                      JUMP Z, fWriteMask
132  11201                      ADD sInArg2, 01
133  14806                      SL0 sAsicMask
134  2212D                      JUMP fNextAsic
135                fSetAsicBit:
135  04980                      OR sAsicMaskFinal, sAsicMask
136  25000                      RETURN
137                 fWriteMask:
137  0100D                      LOAD sInArg0, rAsicMask
138  00190                      LOAD sInArg1, sAsicMaskFinal
139  20145                      CALL fWriteReg
13A  25000                      RETURN

13B                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
13B                             ;;Output an acknowledge, hold until request drops
13B                             ;; sInArg0    - Modified
13B                             ;; sInArg1-3  - Unmodified
13B                             ;; sOutArg0-3 - Unused
13B                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
13B                       fAck:
13B  01001                      LOAD sInArg0, 01
13C  14A06                      SL0 sStartupFail
13D  040A0                      OR sInArg0, sStartupFail
13E  2D020                      OUTPUT sInArg0, opHandshaking
13F                   fAckWait:
13F  09004                      INPUT sInArg0, ipHandshaking
140  1400E                      SR0 sInArg0
141  3A13F                      JUMP C, fAckWait
142  01000                      LOAD sInArg0, 00
143  2D020                      OUTPUT sInArg0, opHandshaking
144  25000                      RETURN

145                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
145                             ;;Do a raw reg write (not to ASIC or ADC)
145                             ;; sInArg0    - Write address
145                             ;; sInArg1    - Write data
145                             ;; sInArg2    - Modified
145                             ;; sInArg3    - Unmodified
145                             ;; sOutArg0   - Fail flag in bit 0 (from fWaitRegAck)
145                             ;; sOutArg1-3 - Unused
145                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
145                  fWriteReg:
145  2D001                      OUTPUT sInArg0, opRegWrAddr
146  2D102                      OUTPUT sInArg1, opRegWrData
147  01200                      LOAD sInArg2, 00
148  2D204                      OUTPUT sInArg2, opAdcReg
149  2D208                      OUTPUT sInArg2, opAsicReg
14A  01203                      LOAD sInArg2, cRegWrite
14B  2D210                      OUTPUT sInArg2, opRegRequest
14C  2016A                      CALL fWaitRegAck
14D  04A40                      OR sStartupFail, sOutArg0      ; Store the fail flag into the fail register
14E  25000                      RETURN

14F                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
14F                             ;;Do an ADC reg write
14F                             ;; sInArg0    - Write address (ADC space)
14F                             ;; sInArg1    - Write data
14F                             ;; sInArg2    - ADC selection
14F                             ;; sInArg3    - Modified
14F                             ;; sOutArg0   - Fail flag in bit 0 (from fWaitRegAck)
14F                             ;; sOutArg1-3 - Unused
14F                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
14F                  fWrAdcReg:
14F  2D001                      OUTPUT sInArg0, opRegWrAddr
150  2D102                      OUTPUT sInArg1, opRegWrData
151  00320                      LOAD sInArg3, sInArg2          ;Input Adc select is bits 1:0
152  14306                      SL0 sInArg3
153  14306                      SL0 sInArg3
154  14306                      SL0 sInArg3                    ;Adc select bits are 4:3
155  05380                      OR sInArg3, 80
156  2D304                      OUTPUT sInArg3, opAdcReg
157  01300                      LOAD sInArg3, 00
158  2D308                      OUTPUT sInArg3, opAsicReg
159  01303                      LOAD sInArg3, cRegWrite
15A  2D310                      OUTPUT sInArg3, opRegRequest
15B  2016A                      CALL fWaitRegAck
15C  04A40                      OR sStartupFail, sOutArg0      ; Store the fail flag into the fail register
15D  25000                      RETURN

15E                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
15E                             ;;Do an ASIC test command (ADDR = 0, CMD = 0)
15E                             ;; sInArg0    - Unmodified
15E                             ;; sInArg1    - Modified
15E                             ;; sInArg2    - ASIC number
15E                             ;; sInArg3    -
15E                             ;; sOutArg0   -
15E                             ;; sOutArg1-3 -
15E                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
15E                 fWrAsicReg:
15E  01100                      LOAD sInArg1, 00
15F  2D101                      OUTPUT sInArg1, opRegWrAddr
160  2D102                      OUTPUT sInArg1, opRegWrData
161  01180                      LOAD sInArg1, 80
162  04120                      OR sInArg1, sInArg2
163  2D108                      OUTPUT sInArg1, opAsicReg
164  01300                      LOAD sInArg3, 00
165  2D304                      OUTPUT sInArg3, opAdcReg
166  01303                      LOAD sInArg3, cRegWrite
167  2D310                      OUTPUT sInArg3, opRegRequest
168  2016A                      CALL fWaitRegAck               ; Don't store fails, as the ASIC may just be missing
169  25000                      RETURN

16A                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
16A                             ;;Wait for a register
16A                             ;; sInArg0    - Modified
16A                             ;; sInArg1    - Modified
16A                             ;; sInArg2    - Modified
16A                             ;; sInArg3    - Modified
16A                             ;; sOutArg0   - Fail flag in bit 0
16A                             ;; sOutArg1-3 - Unused
16A                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
16A                fWaitRegAck:
16A  01B00                      LOAD sScratch0, 00
16B  01C00                      LOAD sScratch1, 00
16C  01300                      LOAD sInArg3, 00
16D                  fWaitLoop:
16D  11301                      ADD sInArg3, 01
16E  13B00                      ADDCY sScratch0, 00
16F  13C00                      ADDCY sScratch1, 00
170  1DC08                      COMPARE sScratch1, 08
171  3217B                      JUMP Z, fTimeout
172  09000                      INPUT sInArg0, ipVcRegInStatus
173  1400E                      SR0 sInArg0                    ; Rotate LSB (ack) to carry
174  3E16D                      JUMP NC, fWaitLoop
175  01300                      LOAD sInArg3, 00               ; Clear the timeout register if we succeeded
176                    fReturn:
176  01100                      LOAD sInArg1, 00               ; Drop the register request
177  2D110                      OUTPUT sInArg1, opRegRequest
178  00400                      LOAD sOutArg0, sInArg0         ; Return fail as bit0 of sOutArg0
179  04430                      OR sOutArg0, sInArg3           ; Fail can also be from a timeout
17A  25000                      RETURN
17B                   fTimeout:
17B  01301                      LOAD sInArg3, 01
17C  22176                      JUMP fReturn

17D                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
17D                             ;;Idle for ~300 ms
17D                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
17D                 fWait300ms:
17D  01340                      LOAD sInArg3, 40
17E                     fWait3:
17E  1D300                      COMPARE sInArg3, 00
17F  31000                      RETURN Z
180  011FF                      LOAD sInArg1, FF
181  012FF                      LOAD sInArg2, FF
182  20185                      CALL fLongWait
183  19301                      SUB sInArg3, 01
184  2217E                      JUMP fWait3

185                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
185                             ;;Idle for sInArg1 * sInArg2 * 8 clock cycles
185                             ;; sInArg0    - Modified
185                             ;; sInArg1    - Long cycles to wait
185                             ;; sInArg2    - Cycles to wait per long cycle
185                             ;; sOutArg0-3 - Unused
185                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
185                  fLongWait:
185  1D100                      COMPARE sInArg1, 00
186  31000                      RETURN Z
187  00020                      LOAD sInArg0, sInArg2
188  2018B                      CALL fWait
189  19101                      SUB sInArg1, 01
18A  22185                      JUMP fLongWait

18B                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
18B                             ;;Idle for sInArg0 * 8 clock cycles (80 ns) (~20 us for 0xFF)
18B                             ;; sInArg0    - Cycles to wait
18B                             ;; sInArg1-3  - Unmodified
18B                             ;; sOutArg0-3 - Unused
18B                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
18B                      fWait:
18B  1D000                      COMPARE sInArg0, 00
18C  31000                      RETURN Z
18D  19001                      SUB sInArg0, 01
18E  2218B                      JUMP fWait

18F                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
18F                             ;;Utility function to store inputs into the scratchpad
18F                             ;; This way we can guarantee inputs will not be overwritten.
18F                             ;; Call this at the beginning of a function.
18F                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
18F               fStoreInputs:
18F  2F030                      STORE sInArg0, mInput0
190  2F131                      STORE sInArg1, mInput1
191  2F232                      STORE sInArg2, mInput2
192  2F333                      STORE sInArg3, mInput3
193  25000                      RETURN

194                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
194                             ;;Utility function to fetch inputs from the scratchpad
194                             ;; Call this just before the RETURN of a function.
194                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
194               fFetchInputs:
194  0B030                      FETCH sInArg0, mInput0
195  0B131                      FETCH sInArg1, mInput1
196  0B232                      FETCH sInArg2, mInput2
197  0B333                      FETCH sInArg3, mInput3
198  25000                      RETURN

                                ;


PSM files that have been assembled
----------------------------------
    /afs/slac.stanford.edu/u/eb/kurtisn/projects/epix/devel/firmware/common/EpixStartupGen2/code/EpixStartupCode.psm


List of defined constants
-------------------------
   CONSTANT name      Value  Source PSM file    
   -------------      -----  ---------------    
   BEL                07
   BS                 08
   CR                 0D
   DCS                90
   DEL                7F
   ESC                1B
   HT                 09
   LF                 0A
   NUL                00
   ST                 9C
   VT                 0B
   cAdcMixedBitPatt   0C     EpixStartupCode.psm
   cAdcNoTestPatt     00     EpixStartupCode.psm
   cAdcPdwn           07     EpixStartupCode.psm
   cAdcPup            00     EpixStartupCode.psm
   cAdcRegEn          80     EpixStartupCode.psm
   cAdcTransferBit    01     EpixStartupCode.psm
   cAllGood           7F     EpixStartupCode.psm
   cClk50MHz          01     EpixStartupCode.psm
   cLastAdc           02     EpixStartupCode.psm
   cLastAsic          03     EpixStartupCode.psm
   cLastData          13     EpixStartupCode.psm
   cLastDataDelay     25     EpixStartupCode.psm
   cLastFrame         02     EpixStartupCode.psm
   cPowerUp           03     EpixStartupCode.psm
   cPowerUpAll        07     EpixStartupCode.psm
   cRegWrite          03     EpixStartupCode.psm
   cSaciClkBit        04     EpixStartupCode.psm
   cStartFrameDelay   13     EpixStartupCode.psm
   datestamp_day      07
   datestamp_month    04
   datestamp_year     0F
   ipAdcMatchCount    03     EpixStartupCode.psm
   ipAdcValidCount    02     EpixStartupCode.psm
   ipHandshaking      04     EpixStartupCode.psm
   ipVcRegInData      01     EpixStartupCode.psm
   ipVcRegInStatus    00     EpixStartupCode.psm
   mBaseChDelay       08     EpixStartupCode.psm
   mCurAdc            00     EpixStartupCode.psm
   mCurCh             01     EpixStartupCode.psm
   mCurDelay          02     EpixStartupCode.psm
   mFailFlag0         10     EpixStartupCode.psm
   mFailFlag1         11     EpixStartupCode.psm
   mFailFlag2         12     EpixStartupCode.psm
   mFirstGood         03     EpixStartupCode.psm
   mFrameDelay0       05     EpixStartupCode.psm
   mFrameDelay1       06     EpixStartupCode.psm
   mFrameDelay2       07     EpixStartupCode.psm
   mInput0            30     EpixStartupCode.psm
   mInput1            31     EpixStartupCode.psm
   mInput2            32     EpixStartupCode.psm
   mInput3            33     EpixStartupCode.psm
   opAdcReg           04     EpixStartupCode.psm
   opAsicReg          08     EpixStartupCode.psm
   opHandshaking      20     EpixStartupCode.psm
   opRegRequest       10     EpixStartupCode.psm
   opRegWrAddr        01     EpixStartupCode.psm
   opRegWrData        02     EpixStartupCode.psm
   rAdcPdwn           1E     EpixStartupCode.psm
   rAdcRegExecute     FF     EpixStartupCode.psm
   rAdcRegTestPatt    0D     EpixStartupCode.psm
   rAsicMask          0D     EpixStartupCode.psm
   rBaseDataDelay     63     EpixStartupCode.psm
   rBaseFrameDelay    60     EpixStartupCode.psm
   rClock             26     EpixStartupCode.psm
   rPower             08     EpixStartupCode.psm
   rSaciClkBit        28     EpixStartupCode.psm
   timestamp_hours    0D
   timestamp_minutes  2D
   timestamp_seconds  23


  No tables defined


List of text strings
--------------------
   STRING name  Value          Source PSM file
   -----------  -----          ---------------
   datestamp$   "07 Apr 2015"
   timestamp$   "13:45:35"


List of line labels
-------------------
    Label                Addr  Source PSM file    
 --------                ----  ---------------    
    fAck                 13B   EpixStartupCode.psm
    fAckWait             13F   EpixStartupCode.psm
    fAlignAgain          009   EpixStartupCode.psm
    fAlignFail           011   EpixStartupCode.psm
    fAlignFinish         012   EpixStartupCode.psm
    fClockUp             01D   EpixStartupCode.psm
    fCycleAdcs           026   EpixStartupCode.psm
    fDataAlign           0CE   EpixStartupCode.psm
    fDataMeasure         0DF   EpixStartupCode.psm
    fDataSuccessCheck    058   EpixStartupCode.psm
 *  fFetchInputs         194   EpixStartupCode.psm
    fFindAsics           127   EpixStartupCode.psm
    fFirstGood           0F1   EpixStartupCode.psm
    fFpgaOutUp           022   EpixStartupCode.psm
    fFrameAlign          061   EpixStartupCode.psm
    fFrameChIncr         076   EpixStartupCode.psm
    fFrameFail           07C   EpixStartupCode.psm
    fFrameFineAlign      080   EpixStartupCode.psm
    fFrameFineFirstGood  0A6   EpixStartupCode.psm
    fFrameFineIncrData   0C5   EpixStartupCode.psm
    fFrameFineLastGood   0AC   EpixStartupCode.psm
    fFrameFineMeasure    094   EpixStartupCode.psm
    fFrameFineNext       087   EpixStartupCode.psm
    fFrameFineNextDelay  0A0   EpixStartupCode.psm
    fFrameFineSetFail    0BA   EpixStartupCode.psm
    fFrameSucc           07E   EpixStartupCode.psm
    fIncrData            113   EpixStartupCode.psm
    fLastGood            0F7   EpixStartupCode.psm
    fLongWait            185   EpixStartupCode.psm
    fMain                000   EpixStartupCode.psm
    fNextAsic            12D   EpixStartupCode.psm
    fNextData            0D5   EpixStartupCode.psm
    fNextDefaultFrame    048   EpixStartupCode.psm
    fNextDelay           0EB   EpixStartupCode.psm
    fNextDis             11D   EpixStartupCode.psm
    fNextEn              035   EpixStartupCode.psm
    fNextFrame           063   EpixStartupCode.psm
    fPowerUp             017   EpixStartupCode.psm
    fReturn              176   EpixStartupCode.psm
    fSetAsicBit          135   EpixStartupCode.psm
    fSetDefaultFrame     03F   EpixStartupCode.psm
    fSetFail             105   EpixStartupCode.psm
 *  fStoreInputs         18F   EpixStartupCode.psm
    fTestDis             11C   EpixStartupCode.psm
    fTestEn              034   EpixStartupCode.psm
    fTimeout             17B   EpixStartupCode.psm
    fWait                18B   EpixStartupCode.psm
    fWait3               17E   EpixStartupCode.psm
    fWait300ms           17D   EpixStartupCode.psm
    fWaitLoop            16D   EpixStartupCode.psm
    fWaitRegAck          16A   EpixStartupCode.psm
    fWrAdcReg            14F   EpixStartupCode.psm
    fWrAsicReg           15E   EpixStartupCode.psm
    fWriteMask           137   EpixStartupCode.psm
    fWriteReg            145   EpixStartupCode.psm

       * Unreferenced label(s)


List of pragma blocks
---------------------
   Name  Addr range  Value
   ----  ----------  -----


Instruction usage statistics
----------------------------
   Instruction  Instances
   -----------  ---------
   ADD          28
   ADDCY        4
   AND          -
   CALL         44
   CALL@        -
   COMPARE      28
   COMPARECY    -
   DISABLE      -
   ENABLE       -
   FETCH        45
   HWBUILD      -
   INPUT        5
   JUMP         41
   JUMP@        -
   LOAD         90
   LOAD&RETURN  -
   OR           12
   OUTPUT       20
   OUTPUTK      -
   REGBANK      -
   RETURN       26
   RETURNI      -
   RL           -
   RR           -
   SL0          8
   SL1          -
   SLA          -
   SLX          -
   SR0          7
   SR1          -
   SRA          -
   SRX          -
   STAR         -
   STORE        42
   SUB          8
   SUBCY        -
   TEST         1
   TESTCY       -
   XOR          -
